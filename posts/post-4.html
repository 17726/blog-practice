<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>17726's blog | 异步JS与网络请求进化史</title>
    <meta
      name="description"
      content="从回调地狱到Promises，再到async/await，回顾JavaScript异步编程和网络请求工具的演进之路。"
    />
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>💻</text></svg>">
    <link rel="stylesheet" href="../css/main.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap"
      rel="stylesheet"
    />
  </head>
  <body>
    <header class="header">
      <div class="container header__container">
        <a href="../index.html" class="header__brand">17726's blog</a>
        <nav class="header__nav">
          <ul class="header__nav-list">
            <li><a href="../index.html" class="header__nav-link">首页</a></li>
            <li><a href="../about.html" class="header__nav-link">关于</a></li>
            <li><a href="../contact.html" class="header__nav-link">留言</a></li>
          </ul>
        </nav>
        <button class="theme-toggle" id="theme-toggle" aria-label="切换主题">
          <svg class="theme-toggle__icon theme-toggle__icon--sun" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
          <svg class="theme-toggle__icon theme-toggle__icon--moon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
        </button>
      </div>
    </header>

    <main class="main-content">
      <div class="container">
        <article class="post">
          <header class="post__header">
            <div class="post__tags">
              <span class="tag">JavaScript</span>
              <span class="tag">异步</span>
              <span class="tag">网络请求</span>
            </div>
            <h1 class="post__title">异步JS与网络请求进化史</h1>
            <div class="post__meta">
              <span>作者：17726</span>
              <span class="post__meta-separator">&middot;</span>
              <time datetime="2025-10-28">2025-10-28</time>
            </div>
          </header>

          <img
            src="https://placehold.co/1200x600/111827/0a7fff?text=Async+JS"
            alt="异步JS与网络请求进化史"
            class="post__image"
          />

          <div class="post__content">
            <p>本文将梳理异步JavaScript和网络请求工具的演变历史，分为两条线索：</p>
            <ul>
                <li><strong>故事主线 (编程思想的进化):</strong> 这是关于我们如何思考和组织异步代码的演变。这条线更抽象，更侧重于“道”。</li>
                <li><strong>故事副线 (网络请求工具的进化):</strong> 这是实现主线思想的具体工具的演变。这条线更具体，更侧重于“术”。</li>
            </ul>

            <h2>19.1 起点：为何需要异步？</h2>
            <p>AJAX，即 Asynchronous JavaScript and XML（异步的 JavaScript 和 XML），是异步概念的起点。</p>
            <h3>为什么需要异步:</h3>
            <ul>
                <li><strong>JavaScript 的单线程本质：</strong> 一次只能做一件事。如果所有操作都是同步的，一个耗时的操作（如网络请求）会阻塞整个页面的渲染和交互，导致页面“卡死”。</li>
                <li><strong>同步 (Synchronous) vs. 异步 (Asynchronous)：</strong>
                    <ul>
                        <li><strong>同步：</strong> 厨师必须做完一道菜（比如炖汤，需要2小时），才能开始下一道菜。期间厨房完全卡住，无法响应任何新点单。</li>
                        <li><strong>异步：</strong> 耗时操作被委托出去（汤在灶上炖着），主线程（厨师）可以继续处理其他任务。</li>
                    </ul>
                </li>
                <li><strong>事件循环 (Event Loop)：</strong> 这是JS实现异步的底层机制。主线程（厨师）有一个任务列表（Task Queue）。当异步操作完成时（灶台通知“汤好了”），一个回调函数被放入任务列表，等待主线程空闲时执行。</li>
            </ul>

            <h2>19.2 混沌时代: 回调函数与 XHR</h2>
            <h3>编程思想：回调函数 (Callback)</h3>
            <p><strong>定义:</strong> 将一个函数作为参数传递给另一个函数，在异步操作完成后执行这个被传递的函数。</p>
            <p><strong>核心问题:</strong> 回调地狱 (Callback Hell)。当多个异步操作相互依赖时，会导致代码层层嵌套，横向发展，难以阅读和维护。</p>
            <pre><code class="language-javascript">
function doOperation() {
  doStep1(0, (result1) =&gt; {
    doStep2(result1, (result2) =&gt; {
      doStep3(result2, (result3) =&gt; {
        console.log(`结果：${result3}`);
      });
    });
  });
}
            </code></pre>
            <h3>网络请求工具：XMLHttpRequest (XHR)</h3>
            <p><strong>定义:</strong> 浏览器提供的、用于发起异步 HTTP 请求的原生 API。</p>
            <p><strong>特点:</strong> 完全基于回调函数工作，是造成回调地狱的直接原因之一。早期常与 XML 配合，后被 JSON 取代。</p>
            <pre><code class="language-javascript">
// 一个简单的 XHR 例子
document.querySelector("#xhr").addEventListener("click", () =&gt; {
  const log = document.querySelector("#log");
  log.textContent = "";
  const xhr = new XMLHttpRequest();
  xhr.addEventListener("loadend", () =&gt; {
    log.textContent = `${log.textContent}完成！状态码：${xhr.status}`;
  });
  xhr.open(
    "GET",
    "https://raw.githubusercontent.com/mdn/content/main/files/en-us/_wikihistory.json",
  );
  xhr.send();
});
            </code></pre>

            <h2>19.3 秩序建立：Promise</h2>
            <h3>编程思想：Promise</h3>
            <ol>
                <li><strong>核心理念:</strong> 从“被动回调”到“主动承诺”。Promise 是一个代表了未来某个时刻才会产生的结果的容器对象。就像外卖订单凭证，你可以随时查看状态，而不是被动等待。</li>
                <li><strong>状态:</strong>
                    <ul>
                        <li><strong>待定（pending）：</strong> 初始状态。</li>
                        <li><strong>已兑现（fulfilled）：</strong> 操作成功完成。</li>
                        <li><strong>已拒绝（rejected）：</strong> 操作失败。</li>
                    </ul>
                </li>
                <li><strong>核心用法：</strong> <code>.then()</code>, <code>.catch()</code>, <code>.finally()</code>。<code>.then()</code> 返回一个新的 Promise，从而可以链式调用，解决了回调地狱。</li>
                <li><strong>创建Promise：</strong> 使用 <code>new Promise(executor)</code> 可以将基于回调的旧版异步函数封装成现代的 Promise API。</li>
            </ol>
            <pre><code class="language-javascript">
function setAlarm(person, delay) {
    return new Promise((resolve, reject) =&gt; {
        if (isNaN(delay) || delay &lt; 0) {
            reject(new Error("Alarm delay must not be negative"));
        }
        window.setTimeout(() =&gt; {
            resolve(`Wake up, ${person}`);
        }, delay);
    });
}

alarmbutton.addEventListener("click", () =&gt; {
    setAlarm(name.value, parseInt(delay.value, 10))
        .then((message) =&gt; output.textContent = message)
        .catch((error) =&gt; output.textContent = `Couldn't set alarm: ${error.message}`);
});
            </code></pre>
            <h3>网络请求工具：Fetch API</h3>
            <p><strong>定义:</strong> 浏览器原生的、用于替代 XHR 的现代网络请求 API。</p>
            <p><strong>特点:</strong> 天生基于 Promise。调用 <code>fetch()</code> 直接返回一个 Promise。</p>
            <p><strong>用法:</strong> <code>fetch()</code> 返回的 Promise 在第一个 <code>.then()</code> 中拿到的是 Response 对象，需要调用 <code>.json()</code> 或 <code>.text()</code> 等方法来获取真实数据，这些方法本身也返回 Promise。</p>

            <h2>19.4 优雅终章：async/await 与 Axios</h2>
            <h3>编程思想：async/await</h3>
            <p><strong>核心理念:</strong> 它是建立在 Promise 之上的语法糖，让异步代码看起来像同步代码，极大提高了可读性。</p>
            <ul>
                <li><strong>async:</strong> 用在函数声明前，表示这是一个异步函数，它会隐式地返回一个 Promise。</li>
                <li><strong>await:</strong> 只能用在 <code>async</code> 函数内部。它会“暂停”函数的执行，等待它后面的 Promise 完成，然后返回结果。</li>
                <li><strong>错误处理:</strong> 使用 <code>try...catch</code> 结构，更符合传统编程习惯。</li>
            </ul>
            <pre><code class="language-javascript">
async function updateDisplay(verse) {
    try {
        const url = `${verse}.txt`;
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`HTTP 错误：${response.status}`);
        }
        const text = await response.text();
        poemDisplay.textContent = text;
    } catch (error) {
        poemDisplay.textContent = `获取诗歌失败:${error}`;
    }
}

// 对比 fetch().then()
fetch(url)
    .then((response) =&gt; {
        if (!response.ok) {
            throw new Error(`HTTP 错误：${response.status}`);
        }
        return response.text();
    })
    .then((text) =&gt; {
        poemDisplay.textContent = text;
    })
    .catch((error) =&gt; {
        poemDisplay.textContent = `获取诗歌失败：${error}`;
    });
            </code></pre>
            <h3>网络请求工具：Axios</h3>
            <p><strong>定义:</strong> 一个功能强大的第三方 HTTP 请求库。</p>
            <p><strong>特点:</strong>
                <ul>
                    <li>基于 Promise，底层封装了 XHR。</li>
                    <li>解决了 Fetch 的一些痛点：自动转换 JSON、更好的错误处理（能捕获 HTTP 错误）。</li>
                    <li>提供了更强大的功能：拦截器 (Interceptors)、请求取消、超时设置等。</li>
                </ul>
            </p>
            <p><strong>评价:</strong> 在 Vue/React 等工程化项目中，是事实上的标准和首选。</p>

            <h2>19.5 总结</h2>
            <ol>
                <li><strong>起点:</strong> 我们想做异步请求，但只有回调这种原始思想，和 XHR 这个难用的工具。</li>
                <li><strong>革命:</strong> Promise 思想横空出世，解决了回调地狱。为了配合这个新思想，浏览器推出了 Fetch 这个新工具。</li>
                <li><strong>升华:</strong> <code>async/await</code> 思想让 Promise 的使用变得无比优雅。而社区则在 Promise 的基础上，打造了 Axios 这个功能更全面的工业级工具。</li>
            </ol>
          </div>

          <footer class="post__footer">
            <a href="../index.html" class="post__back-link">&larr; 返回所有文章</a>
          </footer>
        </article>
      </div>
    </main>

    <footer class="footer">
      <div class="container footer__container">
        <p class="footer__copyright">&copy; 2025 17726's blog. 版权所有.</p>
      </div>
    </footer>
    <script src="../js/main.js"></script>
  </body>
</html>
